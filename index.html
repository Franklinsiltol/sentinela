<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentinela - Análise Inteligente de Conversas</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
    <!-- Adicionar a biblioteca Google APIs -->
    <script src="https://apis.google.com/js/api.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* ... (todo o CSS permanece igual) ... */
    </style>
</head>
<body>
    <!-- ... (todo o HTML permanece igual) ... -->

    <script>
        // =============================================
        // SISTEMA DE AUTENTICAÇÃO VIA CREDENCIAL JSON
        // =============================================
        let serviceAccountCredentials = null;
        let googleApiLoaded = false;

        // Elementos DOM da autenticação JSON
        const jsonAuthDOM = {
            fileUpload: document.getElementById('jsonFileUpload'),
            textArea: document.getElementById('jsonTextArea'),
            loadBtn: document.getElementById('loadJsonCreds'),
            authStatus: document.getElementById('jsonAuthStatus')
        };

        // Event Listeners para autenticação JSON
        jsonAuthDOM.loadBtn.addEventListener('click', handleJsonAuth);
        jsonAuthDOM.fileUpload.addEventListener('change', handleFileUploadChange);

        function handleFileUploadChange(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    jsonAuthDOM.textArea.value = e.target.result;
                    updateJsonAuthStatus('Credencial carregada do arquivo', 'info');
                } catch (error) {
                    updateJsonAuthStatus('Erro ao ler arquivo: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        async function handleJsonAuth() {
            const jsonContent = jsonAuthDOM.textArea.value.trim();
            
            if (!jsonContent) {
                updateJsonAuthStatus('Por favor, cole o conteúdo JSON ou faça upload do arquivo', 'error');
                return;
            }
            
            try {
                const credentials = JSON.parse(jsonContent);
                
                // Validar estrutura básica da credencial
                if (!credentials.type || !credentials.project_id || !credentials.private_key) {
                    throw new Error('Estrutura JSON inválida. Certifique-se de que é uma credencial de service account válida.');
                }
                
                if (credentials.type !== 'service_account') {
                    throw new Error('Tipo de credencial inválido. Deve ser "service_account".');
                }
                
                serviceAccountCredentials = credentials;
                updateJsonAuthStatus('✅ Credencial carregada com sucesso!', 'authenticated');
                
                // Carregar Google APIs quando a credencial for carregada
                await loadGoogleApis();
                
                showAlert('✅ Credencial JSON carregada com sucesso! Agora você pode carregar dados do Google Sheets.', 'success');
                
            } catch (error) {
                console.error('Erro ao processar credencial JSON:', error);
                updateJsonAuthStatus('❌ Erro: ' + error.message, 'error');
            }
        }

        function updateJsonAuthStatus(message, status) {
            jsonAuthDOM.authStatus.innerHTML = `
                <i class="fas fa-${getJsonStatusIcon(status)}"></i>
                <span>${message}</span>
            `;
            jsonAuthDOM.authStatus.className = `auth-status ${status}`;
        }

        function getJsonStatusIcon(status) {
            switch(status) {
                case 'authenticated': return 'check-circle';
                case 'info': return 'info-circle';
                case 'error': return 'exclamation-circle';
                default: return 'exclamation-triangle';
            }
        }

        function isJsonAuthenticated() {
            return serviceAccountCredentials !== null;
        }

        // =============================================
        // CARREGAMENTO ROBUSTO DA BIBLIOTECA GOOGLE APIS
        // =============================================
        function loadGoogleApis() {
            return new Promise((resolve, reject) => {
                // Verificar se já está carregado
                if (window.gapi && window.gapi.client) {
                    googleApiLoaded = true;
                    resolve();
                    return;
                }

                // Verificar se a biblioteca está disponível
                if (!window.gapi) {
                    reject(new Error('Biblioteca Google APIs não encontrada. Verifique se o script foi carregado.'));
                    return;
                }

                // Configurar timeout
                const timeout = setTimeout(() => {
                    reject(new Error('Timeout ao carregar Google APIs. Verifique sua conexão.'));
                }, 30000);

                // Carregar o cliente
                gapi.load('client', {
                    callback: () => {
                        clearTimeout(timeout);
                        googleApiLoaded = true;
                        console.log('✅ Google APIs carregado com sucesso');
                        resolve();
                    },
                    onerror: () => {
                        clearTimeout(timeout);
                        reject(new Error('Erro ao carregar Google APIs client'));
                    },
                    timeout: 10000,
                    ontimeout: () => {
                        clearTimeout(timeout);
                        reject(new Error('Timeout ao carregar Google APIs client'));
                    }
                });
            });
        }

        // =============================================
        // FUNÇÃO PARA CARREGAR DO GOOGLE SHEETS COM CREDENCIAL JSON
        // =============================================
        async function loadFromGoogleSheetsWithJson(sheetId, sheetName) {
            if (!isJsonAuthenticated()) {
                throw new Error('Credencial JSON não carregada. Faça upload da credencial primeiro.');
            }

            if (!googleApiLoaded) {
                throw new Error('Google APIs não carregado. Tente novamente.');
            }

            try {
                // Verificar se gapi.client está disponível
                if (!gapi.client) {
                    throw new Error('Google API client não inicializado');
                }

                // Configurar autenticação JWT
                const authResponse = await gapi.client.init({
                    apiKey: '', // Não necessário para service account
                    clientId: serviceAccountCredentials.client_email,
                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                    scope: 'https://www.googleapis.com/auth/spreadsheets.readonly'
                });

                // Para service account, precisamos usar uma abordagem diferente
                // já que gapi.auth2 não suporta JWT diretamente no navegador
                // Vamos usar a API fetch diretamente com JWT
                const token = await getAccessToken();
                
                const response = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetName || 'Página1'}?access_token=${token}`
                );

                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status} - ${response.statusText}`);
                }

                const data = await response.json();
                const values = data.values;
                
                if (!values || values.length === 0) {
                    throw new Error('A planilha está vazia ou não contém dados válidos');
                }

                // Processar dados
                const headers = values[0];
                const rows = values.slice(1);

                const formattedData = rows.map(row => {
                    const item = {};
                    headers.forEach((header, index) => {
                        item[header] = row[index] || '';
                    });
                    return item;
                });

                rawData = formattedData;

                // Preencher selects de mapeamento
                populateColumnMappingSelects(headers);

                // Mostrar modal para mapeamento
                document.getElementById('columnMappingModal').style.display = 'flex';

                showAlert('✅ Dados carregados com sucesso (via Service Account)', 'success');
                
            } catch (error) {
                console.error('Erro ao carregar do Google Sheets (Service Account):', error);
                throw new Error(`Não foi possível carregar os dados: ${error.message}`);
            }
        }

        // =============================================
        // GERAR TOKEN DE ACESSO JWT
        // =============================================
        async function getAccessToken() {
            if (!serviceAccountCredentials) {
                throw new Error('Credenciais não carregadas');
            }

            try {
                // Criar JWT
                const header = {
                    alg: 'RS256',
                    typ: 'JWT'
                };

                const now = Math.floor(Date.now() / 1000);
                const payload = {
                    iss: serviceAccountCredentials.client_email,
                    scope: 'https://www.googleapis.com/auth/spreadsheets.readonly',
                    aud: 'https://oauth2.googleapis.com/token',
                    exp: now + 3600,
                    iat: now
                };

                // Codificar header e payload
                const encodedHeader = base64urlEncode(JSON.stringify(header));
                const encodedPayload = base64urlEncode(JSON.stringify(payload));
                const signatureInput = `${encodedHeader}.${encodedPayload}`;

                // Assinar com a chave privada
                const signature = await signJWT(signatureInput, serviceAccountCredentials.private_key);
                const encodedSignature = base64urlEncode(signature);

                const jwt = `${signatureInput}.${encodedSignature}`;

                // Trocar JWT por access token
                const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`
                });

                if (!tokenResponse.ok) {
                    throw new Error(`Erro ao obter token: ${tokenResponse.status}`);
                }

                const tokenData = await tokenResponse.json();
                return tokenData.access_token;

            } catch (error) {
                console.error('Erro ao gerar token JWT:', error);
                throw new Error(`Falha na autenticação: ${error.message}`);
            }
        }

        // =============================================
        // FUNÇÕES AUXILIARES PARA JWT
        // =============================================
        function base64urlEncode(str) {
            return btoa(str)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        async function signJWT(data, privateKey) {
            try {
                // Remover headers/footers da chave privada
                const pemContents = privateKey
                    .replace('-----BEGIN PRIVATE KEY-----', '')
                    .replace('-----END PRIVATE KEY-----', '')
                    .replace(/\s/g, '');

                // Converter PEM para ArrayBuffer
                const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));

                // Importar chave
                const cryptoKey = await window.crypto.subtle.importKey(
                    'pkcs8',
                    binaryDer,
                    {
                        name: 'RSASSA-PKCS1-v1_5',
                        hash: { name: 'SHA-256' }
                    },
                    false,
                    ['sign']
                );

                // Assinar dados
                const signature = await window.crypto.subtle.sign(
                    'RSASSA-PKCS1-v1_5',
                    cryptoKey,
                    new TextEncoder().encode(data)
                );

                return new Uint8Array(signature);
            } catch (error) {
                console.error('Erro ao assinar JWT:', error);
                throw new Error('Falha ao assinar token JWT');
            }
        }

        // =============================================
        // SISTEMA DE MONITORIA ATUALIZADO
        // =============================================
        const MONITORING_CONSTANTS = {
            RATING_MAP: { 'Below': 1, 'Meets': 2, 'Above': 3 },
            FILTER_ALL: 'all'
        };

        let MONITORING_STAGE_KEYS = [];
        let MONITORING_STAGE_LABELS = [];
        let monitoringAllData = [];
        let monitoringCharts = {};
        let MONITORING_NON_CONFORMITY_FIELD = '';

        // Elementos DOM da Monitoria
        const monitoringDOM = {
            sheetIdInput: document.getElementById('monitoringSheetId'),
            sheetNameInput: document.getElementById('monitoringSheetName'),
            loadDataBtn: document.getElementById('loadMonitoringDataBtn'),
            loader: document.getElementById('monitoringLoader'),
            dashboardContent: document.getElementById('monitoring-dashboard-content'),
            coordFilter: document.getElementById('coordFilter'),
            poloFilter: document.getElementById('poloFilter'),
            execFilter: document.getElementById('execFilter'),
            feedbackTableBody: document.querySelector('#feedbackTable tbody')
        };

        monitoringDOM.loadDataBtn.addEventListener('click', loadMonitoringData);
        [monitoringDOM.coordFilter, monitoringDOM.poloFilter, monitoringDOM.execFilter].forEach(el => {
            el.addEventListener('change', applyMonitoringFiltersAndRender);
        });

        async function loadMonitoringData() {
            const sheetId = monitoringDOM.sheetIdInput.value.trim();
            const sheetName = monitoringDOM.sheetNameInput.value.trim();

            if (!sheetId) {
                alert('Por favor, insira o ID da planilha.');
                return;
            }

            if (!isJsonAuthenticated()) {
                alert('Por favor, carregue a credencial JSON primeiro.');
                return;
            }

            if (!googleApiLoaded) {
                alert('Google APIs não carregado. Aguarde e tente novamente.');
                return;
            }

            monitoringDOM.loadDataBtn.disabled = true;
            monitoringDOM.loader.style.display = 'block';
            monitoringDOM.dashboardContent.style.display = 'none';
            monitoringDOM.loader.textContent = 'Carregando dados... ⏳';

            try {
                const token = await getAccessToken();
                
                const response = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${sheetName || 'Página1'}?access_token=${token}`
                );

                if (!response.ok) {
                    throw new Error(`Erro HTTP: ${response.status} - ${await response.text()}`);
                }

                const data = await response.json();
                const values = data.values;
                
                if (!values || values.length === 0) {
                    throw new Error('A planilha está vazia ou não contém dados válidos');
                }

                const raw_headers = values[0];
                const dataRows = values.slice(1);
                const headers = raw_headers.map(normalizeHeader);

                processMonitoringData(raw_headers, headers, dataRows);
                
            } catch (error) {
                monitoringDOM.loader.textContent = `❌ Erro: ${error.message}`;
                console.error('Erro ao carregar dados de monitoria:', error);
                alert(`Erro ao carregar dados:\n${error.message}`);
            } finally {
                monitoringDOM.loadDataBtn.disabled = false;
            }
        }

        // ... (o restante das funções de monitoria permanecem iguais) ...

        // =============================================
        // ATUALIZAR FUNÇÃO PRINCIPAL DE CARREGAMENTO
        // =============================================
        async function handleLoadData() {
            const sheetId = document.getElementById('sheetId').value.trim();
            const sheetTab = document.getElementById('sheetTab').value.trim();
            
            if (!sheetId) {
                showAlert('❌ Por favor, insira o ID da planilha', 'error');
                return;
            }
            
            if (!isJsonAuthenticated()) {
                showAlert('❌ Por favor, carregue a credencial JSON primeiro', 'error');
                return;
            }

            if (!googleApiLoaded) {
                showAlert('❌ Google APIs não carregado. Tente novamente.', 'error');
                return;
            }
            
            try {
                showAlert('⏳ Carregando dados do Google Sheets...', 'info');
                await loadFromGoogleSheetsWithJson(sheetId, sheetTab || 'Página1');
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                showAlert('❌ Erro ao carregar dados: ' + error.message, 'error');
            }
        }

        // =============================================
        // INICIALIZAÇÃO DA APLICAÇÃO
        // =============================================
        async function initializeApplication() {
            try {
                // Inicializar analisadores
                appState.textAnalyzer = new TextAnalyzer();
                appState.sentimentAnalyzer = new SentimentAnalyzer();
                
                // Configurar event listeners
                setupEventListeners();
                setupTabNavigation();
                setupMonitoringDateFilter();
                
                // Tentar pré-carregar Google APIs
                try {
                    await loadGoogleApis();
                    console.log('✅ Google APIs pré-carregado com sucesso');
                } catch (error) {
                    console.warn('⚠️ Google APIs não pôde ser pré-carregado:', error.message);
                }
                
                document.getElementById('loadingIndicator').classList.add('hidden');
                document.getElementById('contentArea').classList.remove('hidden');
                
                showAlert('✅ Sistema Sentinela inicializado com sucesso!', 'success');
                
            } catch (error) {
                console.error('Erro na inicialização:', error);
                showAlert('❌ Falha na inicialização do sistema: ' + error.message, 'error');
            }
        }

        function setupEventListeners() {
            // Event listeners existentes
            document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
            document.getElementById('applyFilter').addEventListener('click', applyDateFilter);
            document.getElementById('loadData').addEventListener('click', handleLoadData);
            document.getElementById('fileUpload').addEventListener('change', handleFileUpload);
            document.getElementById('performSearch').addEventListener('click', performWordSearch);
            document.getElementById('clearSearch').addEventListener('click', clearSearch);
            document.getElementById('analyzePhrase').addEventListener('click', analyzePhrase);
            document.getElementById('addStopWord').addEventListener('click', addStopWord);
            document.getElementById('resetStopWords').addEventListener('click', resetStopWords);
            document.getElementById('refreshWordCloud').addEventListener('click', updateWordAnalysis);
            document.getElementById('exportData').addEventListener('click', exportData);
            document.getElementById('refreshData').addEventListener('click', refreshData);
            
            // Event listeners para mapeamento de colunas
            document.getElementById('applyColumnMapping').addEventListener('click', function() {
                updateColumnMappingFromSelects();
                if (applyColumnMappingAndProcess()) {
                    showAlert('✅ Mapeamento aplicado com sucesso!', 'success');
                }
            });
            
            document.getElementById('confirmColumnMapping').addEventListener('click', function() {
                // Atualizar mapeamento a partir do modal
                columnMapping = {
                    texto: document.getElementById('modalColumnTexto').value,
                    agente: document.getElementById('modalColumnAgente').value,
                    data: document.getElementById('modalColumnData').value,
                    email: document.getElementById('modalColumnEmail').value
                };
                
                // Atualizar selects na sidebar
                document.getElementById('columnTexto').value = columnMapping.texto;
                document.getElementById('columnAgente').value = columnMapping.agente;
                document.getElementById('columnData').value = columnMapping.data;
                document.getElementById('columnEmail').value = columnMapping.email;
                
                // Fechar modal
                document.getElementById('columnMappingModal').style.display = 'none';
                
                // Aplicar mapeamento e processar dados
                if (applyColumnMappingAndProcess()) {
                    showAlert('✅ Mapeamento aplicado com sucesso!', 'success');
                }
            });
            
            document.getElementById('cancelColumnMapping').addEventListener('click', function() {
                document.getElementById('columnMappingModal').style.display = 'none';
            });
            
            document.getElementById('closeColumnMappingModal').addEventListener('click', function() {
                document.getElementById('columnMappingModal').style.display = 'none';
            });
            
            // Event listeners para busca
            document.getElementById('wordSearch').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') performWordSearch();
            });
            
            document.getElementById('newStopWord').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') addStopWord();
            });
        }

        function setupTabNavigation() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    switchToTab(tabId);
                });
            });
        }

        function switchToTab(tabId) {
            // Atualizar tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Ativar tab selecionada
            document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');
            
            appState.currentTab = tabId;
            
            // Atualizar conteúdo específico da tab
            if (tabId === 'words' && appState.data.length > 0) {
                updateWordAnalysis();
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            const header = document.getElementById('header');
            
            sidebar.classList.toggle('collapsed');
            mainContent.classList.toggle('expanded');
            header.classList.toggle('collapsed');
            
            appState.isSidebarCollapsed = !appState.isSidebarCollapsed;
        }

        // =============================================
        // FUNÇÕES DE CARREGAMENTO DE DADOS
        // =============================================
        async function handleLoadData() {
            const sheetId = document.getElementById('sheetId').value.trim();
            const sheetTab = document.getElementById('sheetTab').value.trim();
            
            if (!sheetId) {
                showAlert('❌ Por favor, insira o ID da planilha', 'error');
                return;
            }
            
            if (!isJsonAuthenticated()) {
                showAlert('❌ Por favor, carregue a credencial JSON primeiro', 'error');
                return;
            }
            
            try {
                showAlert('⏳ Carregando dados do Google Sheets...', 'info');
                await loadFromGoogleSheetsWithJson(sheetId, sheetTab || 'Página1');
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                showAlert('❌ Erro ao carregar dados: ' + error.message, 'error');
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.csv')) {
                        data = parseCSV(e.target.result);
                    } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                        data = parseExcel(e.target.result);
                    } else {
                        throw new Error('Formato de arquivo não suportado');
                    }
                    
                    rawData = data;
                    
                    if (data.length === 0 || !data[0]) {
                        throw new Error('O arquivo está vazio ou não contém dados válidos');
                    }
                    
                    const headers = Object.keys(data[0]);
                    populateColumnMappingSelects(headers);
                    
                    document.getElementById('columnMappingModal').style.display = 'flex';
                    
                    showAlert('✅ Arquivo carregado com sucesso! Configure o mapeamento das colunas.', 'success');
                    
                } catch (error) {
                    console.error('Erro ao processar arquivo:', error);
                    showAlert('❌ Erro ao processar arquivo: ' + error.message, 'error');
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(csvText) {
            return Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                transform: (value) => value.trim()
            }).data;
        }

        function parseExcel(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            return XLSX.utils.sheet_to_json(worksheet, { defval: '' });
        }

        // =============================================
        // FUNÇÕES DE PROCESSAMENTO DE DADOS
        // =============================================
        function processLoadedData(data) {
            try {
                const processedData = data.map(item => {
                    const sentiment = appState.sentimentAnalyzer.analyze(item.Texto);
                    
                    return {
                        ...item,
                        Sentimento: sentiment.sentiment,
                        Pontuacao: sentiment.score,
                        Confianca: sentiment.confidence,
                        Problemas: detectProblems(item.Texto),
                        Solucoes: detectSolutions(item.Texto)
                    };
                });
                
                appState.data = processedData;
                appState.filteredData = [...processedData];
                
                // Configurar índice de busca
                appState.textAnalyzer.setupSearchIndex(processedData);
                
                updateAllViews();
                showAlert(`✅ ${processedData.length} registros processados com sucesso!`, 'success');
                
            } catch (error) {
                console.error('Erro no processamento:', error);
                showAlert('❌ Erro no processamento dos dados: ' + error.message, 'error');
            }
        }

        function detectProblems(text) {
            const problemKeywords = ['problema', 'erro', 'falha', 'defeito', 'bug', 'não funciona', 'quebrado', 'lento', 'travando'];
            const regex = new RegExp(problemKeywords.join('|'), 'gi');
            const matches = text.match(regex);
            return matches ? matches.length : 0;
        }

        function detectSolutions(text) {
            const solutionKeywords = ['resolvido', 'consertado', 'corrigido', 'funcionando', 'pronto', 'finalizado', 'concluído'];
            const regex = new RegExp(solutionKeywords.join('|'), 'gi');
            const matches = text.match(regex);
            return matches ? matches.length : 0;
        }

        // =============================================
        // FUNÇÕES DE VISUALIZAÇÃO
        // =============================================
        function updateAllViews() {
            updateMetrics();
            updateCharts();
            updateAgentsTable();
            updateDailyTable();
            
            if (appState.currentTab === 'words') {
                updateWordAnalysis();
            }
        }

        function updateCharts() {
            updateSentimentChart();
            updateAgentsChart();
            updateContentChart();
            updateTemporalChart();
            updateTrendsChart();
            updateCorrelationChart();
        }

        function updateSentimentChart() {
            const sentimentCounts = {
                'Muito Positivo': 0, 'Positivo': 0, 'Neutro': 0, 'Negativo': 0, 'Muito Negativo': 0
            };
            
            appState.filteredData.forEach(item => {
                sentimentCounts[item.Sentimento]++;
            });
            
            const data = [{
                values: Object.values(sentimentCounts),
                labels: Object.keys(sentimentCounts),
                type: 'pie',
                marker: {
                    colors: ['#28a745', '#20c997', '#ffc107', '#fd7e14', '#dc3545']
                }
            }];
            
            const layout = {
                title: 'Distribuição de Sentimentos',
                height: 400
            };
            
            Plotly.newPlot('sentimentChart', data, layout, { responsive: true });
        }

        function updateAgentsChart() {
            const agentStats = {};
            
            appState.filteredData.forEach(item => {
                if (!agentStats[item.Agente]) {
                    agentStats[item.Agente] = {
                        count: 0,
                        positive: 0,
                        negative: 0,
                        neutral: 0
                    };
                }
                
                agentStats[item.Agente].count++;
                
                if (item.Sentimento === 'Positivo' || item.Sentimento === 'Muito Positivo') {
                    agentStats[item.Agente].positive++;
                } else if (item.Sentimento === 'Negativo' || item.Sentimento === 'Muito Negativo') {
                    agentStats[item.Agente].negative++;
                } else {
                    agentStats[item.Agente].neutral++;
                }
            });
            
            const sortedAgents = Object.entries(agentStats)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const data = [{
                x: sortedAgents.map(([agent]) => agent),
                y: sortedAgents.map(([_, stats]) => stats.count),
                type: 'bar',
                marker: {
                    color: 'rgb(0, 0, 0)'
                }
            }];
            
            const layout = {
                title: 'Top 10 Agentes por Atendimentos',
                xaxis: { title: 'Agentes' },
                yaxis: { title: 'Número de Atendimentos' },
                height: 400
            };
            
            Plotly.newPlot('agentsChart', data, layout, { responsive: true });
        }

        function updateContentChart() {
            const contentTypes = {
                'Dúvidas': 0,
                'Problemas': 0,
                'Sugestões': 0,
                'Elogios': 0,
                'Outros': 0
            };
            
            appState.filteredData.forEach(item => {
                const text = item.Texto.toLowerCase();
                
                if (text.includes('?') || text.includes('dúvida') || text.includes('como') || text.includes('onde')) {
                    contentTypes['Dúvidas']++;
                } else if (text.includes('problema') || text.includes('erro') || text.includes('não funciona') || text.includes('bug')) {
                    contentTypes['Problemas']++;
                } else if (text.includes('sugestão') || text.includes('melhorar') || text.includes('poderia')) {
                    contentTypes['Sugestões']++;
                } else if (text.includes('obrigado') || text.includes('parabéns') || text.includes('gostei') || text.includes('excelente')) {
                    contentTypes['Elogios']++;
                } else {
                    contentTypes['Outros']++;
                }
            });
            
            const data = [{
                values: Object.values(contentTypes),
                labels: Object.keys(contentTypes),
                type: 'pie',
                marker: {
                    colors: ['#007bff', '#dc3545', '#ffc107', '#28a745', '#6c757d']
                }
            }];
            
            const layout = {
                title: 'Distribuição por Tipo de Conteúdo',
                height: 400
            };
            
            Plotly.newPlot('contentChart', data, layout, { responsive: true });
        }

        function updateTemporalChart() {
            const dailyStats = {};
            
            appState.filteredData.forEach(item => {
                if (!dailyStats[item.Data]) {
                    dailyStats[item.Data] = {
                        count: 0,
                        sentiment: 0
                    };
                }
                
                dailyStats[item.Data].count++;
                dailyStats[item.Data].sentiment += item.Pontuacao;
            });
            
            const dates = Object.keys(dailyStats).sort();
            const counts = dates.map(date => dailyStats[date].count);
            const avgSentiments = dates.map(date => dailyStats[date].sentiment / dailyStats[date].count);
            
            const trace1 = {
                x: dates,
                y: counts,
                type: 'bar',
                name: 'Mensagens',
                yaxis: 'y1'
            };
            
            const trace2 = {
                x: dates,
                y: avgSentiments,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Sentimento Médio',
                yaxis: 'y2',
                line: { color: 'red', width: 3 }
            };
            
            const data = [trace1, trace2];
            
            const layout = {
                title: 'Evolução Temporal - Volume e Sentimento',
                xaxis: { title: 'Data' },
                yaxis: {
                    title: 'Mensagens',
                    side: 'left'
                },
                yaxis2: {
                    title: 'Sentimento Médio',
                    side: 'right',
                    overlaying: 'y'
                },
                height: 400
            };
            
            Plotly.newPlot('temporalChart', data, layout, { responsive: true });
        }

        function updateTrendsChart() {
            const dailyStats = {};
            
            appState.filteredData.forEach(item => {
                if (!dailyStats[item.Data]) {
                    dailyStats[item.Data] = {
                        positive: 0,
                        negative: 0,
                        neutral: 0,
                        total: 0
                    };
                }
                
                dailyStats[item.Data].total++;
                
                if (item.Sentimento === 'Positivo' || item.Sentimento === 'Muito Positivo') {
                    dailyStats[item.Data].positive++;
                } else if (item.Sentimento === 'Negativo' || item.Sentimento === 'Muito Negativo') {
                    dailyStats[item.Data].negative++;
                } else {
                    dailyStats[item.Data].neutral++;
                }
            });
            
            const dates = Object.keys(dailyStats).sort();
            
            const positiveTrend = dates.map(date => dailyStats[date].positive);
            const negativeTrend = dates.map(date => dailyStats[date].negative);
            const neutralTrend = dates.map(date => dailyStats[date].neutral);
            
            const data = [
                {
                    x: dates,
                    y: positiveTrend,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Positivo',
                    line: { color: 'green', width: 3 }
                },
                {
                    x: dates,
                    y: negativeTrend,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Negativo',
                    line: { color: 'red', width: 3 }
                },
                {
                    x: dates,
                    y: neutralTrend,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Neutro',
                    line: { color: 'orange', width: 3 }
                }
            ];
            
            const layout = {
                title: 'Tendências de Sentimento ao Longo do Tempo',
                xaxis: { title: 'Data' },
                yaxis: { title: 'Quantidade' },
                height: 400
            };
            
            Plotly.newPlot('trendsChart', data, layout, { responsive: true });
        }

        function updateCorrelationChart() {
            const agentStats = {};
            
            appState.filteredData.forEach(item => {
                if (!agentStats[item.Agente]) {
                    agentStats[item.Agente] = {
                        messages: 0,
                        avgSentiment: 0,
                        problems: 0,
                        solutions: 0
                    };
                }
                
                agentStats[item.Agente].messages++;
                agentStats[item.Agente].avgSentiment += item.Pontuacao;
                agentStats[item.Agente].problems += item.Problemas;
                agentStats[item.Agente].solutions += item.Solucoes;
            });
            
            Object.keys(agentStats).forEach(agent => {
                agentStats[agent].avgSentiment /= agentStats[agent].messages;
            });
            
            const agents = Object.keys(agentStats);
            const messages = agents.map(agent => agentStats[agent].messages);
            const avgSentiments = agents.map(agent => agentStats[agent].avgSentiment);
            const resolutionRates = agents.map(agent => 
                agentStats[agent].problems > 0 ? agentStats[agent].solutions / agentStats[agent].problems : 0
            );
            
            const data = [{
                x: messages,
                y: avgSentiments,
                mode: 'markers',
                type: 'scatter',
                text: agents,
                marker: {
                    size: resolutionRates.map(rate => Math.max(10, rate * 20)),
                    color: resolutionRates,
                    colorscale: 'Viridis',
                    showscale: true
                }
            }];
            
            const layout = {
                title: 'Correlação: Volume vs. Sentimento vs. Resolução',
                xaxis: { title: 'Volume de Mensagens' },
                yaxis: { title: 'Sentimento Médio' },
                height: 500
            };
            
            Plotly.newPlot('correlationChart', data, layout, { responsive: true });
        }

        function updateAgentsTable() {
            const agentStats = {};
            
            appState.filteredData.forEach(item => {
                if (!agentStats[item.Agente]) {
                    agentStats[item.Agente] = {
                        messages: 0,
                        positive: 0,
                        negative: 0,
                        neutral: 0,
                        problems: 0,
                        solutions: 0,
                        avgSentiment: 0
                    };
                }
                
                agentStats[item.Agente].messages++;
                agentStats[item.Agente].avgSentiment += item.Pontuacao;
                agentStats[item.Agente].problems += item.Problemas;
                agentStats[item.Agente].solutions += item.Solucoes;
                
                if (item.Sentimento === 'Positivo' || item.Sentimento === 'Muito Positivo') {
                    agentStats[item.Agente].positive++;
                } else if (item.Sentimento === 'Negativo' || item.Sentimento === 'Muito Negativo') {
                    agentStats[item.Agente].negative++;
                } else {
                    agentStats[item.Agente].neutral++;
                }
            });
            
            Object.keys(agentStats).forEach(agent => {
                agentStats[agent].avgSentiment /= agentStats[agent].messages;
                agentStats[agent].positiveRate = (agentStats[agent].positive / agentStats[agent].messages) * 100;
                agentStats[agent].resolutionRate = agentStats[agent].problems > 0 ? 
                    (agentStats[agent].solutions / agentStats[agent].problems) * 100 : 0;
            });
            
            const sortedAgents = Object.entries(agentStats)
                .sort((a, b) => b[1].positiveRate - a[1].positiveRate);
            
            let tableHTML = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Agente</th>
                            <th>Mensagens</th>
                            <th>Positivas</th>
                            <th>Negativas</th>
                            <th>Taxa Positiva</th>
                            <th>Sentimento Médio</th>
                            <th>Taxa de Resolução</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            sortedAgents.forEach(([agent, stats]) => {
                tableHTML += `
                    <tr>
                        <td>${agent}</td>
                        <td>${stats.messages}</td>
                        <td>${stats.positive}</td>
                        <td>${stats.negative}</td>
                        <td>${stats.positiveRate.toFixed(1)}%</td>
                        <td>${stats.avgSentiment.toFixed(2)}</td>
                        <td>${stats.resolutionRate.toFixed(1)}%</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            document.getElementById('agentsTable').innerHTML = tableHTML;
        }

        function updateDailyTable() {
            const dailyStats = {};
            
            appState.filteredData.forEach(item => {
                if (!dailyStats[item.Data]) {
                    dailyStats[item.Data] = {
                        messages: 0,
                        agents: new Set(),
                        positive: 0,
                        negative: 0,
                        neutral: 0,
                        avgSentiment: 0,
                        problems: 0,
                        solutions: 0
                    };
                }
                
                dailyStats[item.Data].messages++;
                dailyStats[item.Data].agents.add(item.Agente);
                dailyStats[item.Data].avgSentiment += item.Pontuacao;
                dailyStats[item.Data].problems += item.Problemas;
                dailyStats[item.Data].solutions += item.Solucoes;
                
                if (item.Sentimento === 'Positivo' || item.Sentimento === 'Muito Positivo') {
                    dailyStats[item.Data].positive++;
                } else if (item.Sentimento === 'Negativo' || item.Sentimento === 'Muito Negativo') {
                    dailyStats[item.Data].negative++;
                } else {
                    dailyStats[item.Data].neutral++;
                }
            });
            
            const sortedDates = Object.keys(dailyStats).sort();
            
            let tableHTML = `
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Mensagens</th>
                            <th>Agentes</th>
                            <th>Positivas</th>
                            <th>Negativas</th>
                            <th>Neutras</th>
                            <th>Sentimento Médio</th>
                            <th>Problemas</th>
                            <th>Soluções</th>
                            <th>Taxa Resolução</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            sortedDates.forEach(date => {
                const stats = dailyStats[date];
                stats.avgSentiment /= stats.messages;
                const resolutionRate = stats.problems > 0 ? (stats.solutions / stats.problems) * 100 : 0;
                
                tableHTML += `
                    <tr>
                        <td>${date}</td>
                        <td>${stats.messages}</td>
                        <td>${stats.agents.size}</td>
                        <td>${stats.positive}</td>
                        <td>${stats.negative}</td>
                        <td>${stats.neutral}</td>
                        <td>${stats.avgSentiment.toFixed(2)}</td>
                        <td>${stats.problems}</td>
                        <td>${stats.solutions}</td>
                        <td>${resolutionRate.toFixed(1)}%</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            document.getElementById('dailyTable').innerHTML = tableHTML;
        }

        // =============================================
        // FUNÇÕES DE FILTRO
        // =============================================
        function applyDateFilter() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            let filteredData = [...appState.data];
            
            if (startDate) {
                filteredData = filteredData.filter(item => item.Data >= startDate);
            }
            
            if (endDate) {
                filteredData = filteredData.filter(item => item.Data <= endDate);
            }
            
            appState.filteredData = filteredData;
            updateAllViews();
            
            showAlert(`✅ Filtro aplicado: ${filteredData.length} registros`, 'success');
        }

        function clearSearch() {
            document.getElementById('wordSearch').value = '';
            document.getElementById('sentimentFilter').value = 'all';
            document.getElementById('searchResults').innerHTML = '';
        }

        function analyzePhrase() {
            const phrase = document.getElementById('phraseInput').value.trim();
            if (!phrase) {
                showAlert('⚠️ Digite uma frase para analisar', 'warning');
                return;
            }
            
            const frequency = appState.textAnalyzer.getTopWords().find(([word]) => word === phrase.toLowerCase());
            const sentiment = appState.sentimentAnalyzer.analyze(phrase);
            
            let analysisHTML = `
                <h4>Análise da Frase: "${phrase}"</h4>
                <p><strong>Frequência no dataset:</strong> ${frequency ? frequency[1] : 0} ocorrências</p>
                <p><strong>Sentimento:</strong> ${sentiment.sentiment} (pontuação: ${sentiment.score})</p>
                <p><strong>Confiança:</strong> ${sentiment.confidence}</p>
            `;
            
            // Buscar exemplos da frase
            const examples = appState.textAnalyzer.search(phrase, 'all', 5);
            if (examples.length > 0) {
                analysisHTML += '<h5>Exemplos encontrados:</h5>';
                examples.forEach(example => {
                    analysisHTML += `
                        <div class="search-result-item">
                            <div class="chat-sender">${example.item.Agente} - ${example.item.Data}</div>
                            <div>${example.item.Texto}</div>
                        </div>
                    `;
                });
            } else {
                analysisHTML += '<p>Nenhum exemplo encontrado para esta frase.</p>';
            }
            
            document.getElementById('phraseAnalysis').innerHTML = analysisHTML;
        }

        // =============================================
        // FUNÇÕES DE EXPORTAÇÃO
        // =============================================
        function exportData() {
            const dataToExport = appState.filteredData;
            
            const csv = Papa.unparse(dataToExport);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', 'sentinela_export.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showAlert('✅ Dados exportados com sucesso!', 'success');
        }

        function refreshData() {
            if (appState.data.length === 0) {
                showAlert('⚠️ Nenhum dado carregado para atualizar', 'warning');
                return;
            }
            
            appState.filteredData = [...appState.data];
            updateAllViews();
            showAlert('✅ Dados atualizados com sucesso!', 'success');
        }

        // =============================================
        // INICIALIZAÇÃO
        // =============================================
        document.addEventListener('DOMContentLoaded', initializeApplication);
    </script>
</body>
</html>
